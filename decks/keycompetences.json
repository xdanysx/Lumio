[
  {
    "id": "kc_text_004",
    "type": "text",
    "prompt": "Erkläre, warum Ports benötigt werden, obwohl eine IP-Adresse einen Rechner eindeutig identifiziert.",
    "rubric": [
      ["port"],
      ["dienst", "service", "prozess"],
      ["zuordnung"],
      ["ip adresse"],
      ["gleichzeitig", "mehrere"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Eine IP-Adresse identifiziert nur den Rechner im Netzwerk, aber nicht den einzelnen Port, an dem kommuniziert wird. Auf einem Host laufen mehrere Dienste/Services bzw. Prozesse parallel, z.B. Webserver und Datenbank. Ports erlauben die Zuordnung (Mapping) einer Verbindung zum richtigen Prozess. Dadurch kann ein Rechner über dieselbe IP-Adresse gleichzeitig mehrere Verbindungen und mehrere Anwendungen bedienen."
  },
  {
    "id": "kc_text_005",
    "type": "text",
    "prompt": "Erkläre den Unterschied zwischen well-known ports und registered ports.",
    "rubric": [
      ["well-known"],
      ["registered"],
      ["0-1023"],
      ["1024-49151"],
      ["iana"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Well-known ports sind die standardisierten Ports im Bereich 0-1023, die typischen Basisdiensten zugeordnet sind. Registered ports liegen im Bereich 1024-49151 und werden für Anwendungen/Services registriert, sind aber weniger streng „systemkritisch“ als well-known. Die Verwaltung bzw. Zuteilung solcher Portbereiche erfolgt durch die IANA. Praktisch bedeutet das: well-known = feste Standards, registered = offiziell registrierbare Anwendungs-Ports."
  },
  {
    "id": "kc_text_006",
    "type": "text",
    "prompt": "Warum wird bei FTP häufig der passive Modus verwendet?",
    "rubric": [
      ["ftp"],
      ["passiv", "passive"],
      ["firewall"],
      ["nat"],
      ["client", "verbindung"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Bei FTP gibt es neben der Steuerverbindung auch eine separate Datenverbindung, was in Netzwerken oft Probleme macht. Im passive/passiv Modus baut der Client die Datenverbindung selbst zum Server auf, statt dass der Server zurück zum Client verbindet. Das funktioniert deutlich besser hinter einer Firewall, weil ausgehende Verbindungen vom Client typischerweise erlaubt sind. Auch bei NAT ist passiv hilfreich, weil eingehende Verbindungen zum Client sonst nicht sauber zuordenbar sind. Kurz: passive FTP vereinfacht die Verbindung durch Client-initiierte Datenkanäle."
  },
  {
    "id": "kc_text_007",
    "type": "text",
    "prompt": "Erkläre, warum SSH als sicherer gilt als FTP oder Telnet.",
    "rubric": [
      ["ssh"],
      ["verschluesselt", "verschlüsselt"],
      ["authentifizierung"],
      ["klartext"],
      ["integritaet", "integrität"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "SSH gilt als sicher, weil der gesamte Verkehr verschlüsselt/verschluesselt übertragen wird. Zusätzlich bietet SSH starke Authentifizierung, z.B. per Passwort oder Key-Login. Telnet und klassisches FTP übertragen viele Inhalte im Klartext, inklusive Zugangsdaten, was leicht abfangbar ist. Außerdem prüft SSH Integrität/Integritaet der Daten, damit Manipulationen erkannt werden. Damit schützt SSH Vertraulichkeit, Authentizität und Integrität deutlich besser."
  },
  {
    "id": "kc_text_008",
    "type": "text",
    "prompt": "Ist eine SSH-Verbindung auch ohne ssh-keygen verschlüsselt? Begründe deine Antwort.",
    "rubric": [
      ["ssh"],
      ["verschluesselt", "verschlüsselt"],
      ["ssh-keygen"],
      ["authentifizierung"],
      ["unabhaengig", "unabhängig"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Ja: Eine SSH-Verbindung ist auch ohne ssh-keygen verschlüsselt/verschluesselt. Die Verschlüsselung entsteht beim Verbindungsaufbau durch den SSH-Protokoll-Handshake (Session Keys), das ist unabhängig/unabhaengig davon, wie du dich anmeldest. ssh-keygen betrifft primär die Authentifizierung, also ob du dich mit einem privaten/public Key statt Passwort authentifizierst. Auch bei Passwort-Login bleibt der Transportkanal verschlüsselt. Keys ändern also die Authentifizierung, nicht die grundsätzliche Verschlüsselung des SSH-Tunnels."
  },
  {
    "id": "kc_text_009",
    "type": "text",
    "prompt": "Erkläre, was ein SSH-Tunnel ist und wozu man ihn verwendet.",
    "rubric": [
      ["ssh tunnel", "ssh-tunnel"],
      ["port forwarding"],
      ["verschluesselt", "verschlüsselt"],
      ["weiterleitung"],
      ["lokal", "remote"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "Ein SSH-Tunnel (ssh-tunnel) ist eine verschlüsselt/verschluesselt aufgebaute Verbindung, die anderen Traffic „mittransportiert“. Technisch ist das Port forwarding: Ein lokaler Port wird auf einen remote Dienst weitergeleitet (Weiterleitung), oder umgekehrt. Dadurch kann man z.B. lokal auf einen entfernten Datenbankport zugreifen, als würde er lokal laufen. Das ist praktisch, um unsichere Protokolle abzusichern oder interne Services erreichbar zu machen, ohne sie offen ins Internet zu stellen. Man unterscheidet häufig Local-Forwarding (lokal→remote) und Remote-Forwarding (remote→lokal)."
  },
  {
    "id": "kc_text_010",
    "type": "text",
    "prompt": "Erkläre den Zweck des Dockerfile-Befehls EXPOSE und was er ausdrücklich nicht bewirkt.",
    "rubric": [
      ["expose"],
      ["container"],
      ["port"],
      ["nicht erreichbar", "keine freigabe"],
      ["host"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "EXPOSE (expose) dokumentiert, welchen Port ein Container zur Laufzeit typischerweise nutzt bzw. „lauscht“. Es ist eine Metainformation im Image/Container-Kontext und hilft Tools sowie Lesern des Dockerfile. EXPOSE bewirkt ausdrücklich nicht, dass der Dienst von außen erreichbar ist: ohne Port-Mapping ist es von einem Host aus weiterhin nicht erreichbar bzw. es gibt keine Freigabe. Damit ein Port vom Host aus erreichbar wird, musst du ihn beim Start veröffentlichen (z.B. mit -p). Kurz: EXPOSE beschreibt Ports, öffnet sie aber nicht auf dem Host."
  },
  {
    "id": "kc_text_011",
    "type": "text",
    "prompt": "Was ist eine Docker-Layer und warum machen Layer Docker effizient?",
    "rubric": [
      ["docker layer", "layer"],
      ["image"],
      ["build schritt", "dockerfile"],
      ["cache"],
      ["wiederverwendung"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "Eine Docker-Layer (docker layer/layer) ist eine einzelne Schicht im Docker-Image, die aus einem Build-Schritt im Dockerfile entsteht. Jede Anweisung wie RUN, COPY oder ADD erzeugt typischerweise eine neue Layer im Image. Docker nutzt dafür einen Cache, sodass unveränderte Layer beim erneuten Build nicht neu berechnet werden müssen. Das macht Builds schneller und spart Bandbreite, weil Layer wiederverwendet und separat gepullt werden können. Effizienz entsteht also durch Caching und Wiederverwendung identischer Layer zwischen Images."
  },
  {
    "id": "kc_text_012",
    "type": "text",
    "prompt": "Erkläre den Unterschied zwischen Docker-Image und Docker-Container.",
    "rubric": [
      ["docker image"],
      ["docker container"],
      ["vorlage"],
      ["laufend", "instanz"],
      ["start", "run"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Ein Docker Image (docker image) ist die Vorlage, also ein unveränderliches Paket mit Filesystem und Metadaten. Ein Docker Container (docker container) ist die laufende Instanz dieses Images, also ein konkreter Prozess mit eigener Laufzeitumgebung. Wenn du einen Container startest/run ausführst, wird aus dem Image eine Instanz erzeugt. Das Image ist also das „Bauplan“-Artefakt, der Container das tatsächlich laufende Objekt. Mehrere Container können aus derselben Image-Vorlage gestartet werden."
  },
  {
    "id": "kc_text_013",
    "type": "text",
    "prompt": "Erkläre den Unterschied zwischen rekursiver und autoritativer DNS-Auflösung.",
    "rubric": [
      ["rekursiv"],
      ["autoritaer", "autoritativ"],
      ["dns server", "nameserver"],
      ["anfrage", "auflösung"],
      ["zuständig", "zone"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "Bei einer rekursiven DNS-Auflösung übernimmt ein DNS-Server die komplette Namensauflösung für den Client und fragt ggf. weitere Server ab. Der Client erhält nur das Endergebnis, z.B. die IP-Adresse. Ein autoritativer DNS-Server hingegen ist direkt für eine Zone zuständig und liefert nur Informationen über Domains, für die er verantwortlich ist. Er fragt keine anderen Server weiter. Rekursive Resolver dienen als Vermittler, autoritative Server als Quelle der Wahrheit."
  },
  {
    "id": "kc_text_014",
    "type": "text",
    "prompt": "Was ist der Zweck der Hosts-Datei und wann wird sie verwendet?",
    "rubric": [
      ["hosts"],
      ["localhost"],
      ["dns"],
      ["auflösung"],
      ["vorrang"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Die Hosts-Datei ordnet Domainnamen direkt IP-Adressen zu und wird zur lokalen Namensauflösung verwendet. Sie wird vor einer DNS-Abfrage ausgewertet und hat daher Vorrang vor DNS. Typisch ist der Eintrag von localhost oder das gezielte Umleiten von Domains zu Testzwecken. Dadurch kann DNS lokal überschrieben werden. Die Hosts-Datei wird häufig für Debugging oder Entwicklungsumgebungen genutzt."
  },
  {
    "id": "kc_text_015",
    "type": "text",
    "prompt": "Was ist der Unterschied zwischen A-Record und AAAA-Record?",
    "rubric": [
      ["a record"],
      ["aaaa record"],
      ["ipv4"],
      ["ipv6"],
      ["dns"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Ein A-Record ordnet einer Domain eine IPv4-Adresse zu. Ein AAAA-Record ordnet einer Domain eine IPv6-Adresse zu. Beide sind DNS-Records, unterscheiden sich aber im verwendeten IP-Adressformat. Moderne Systeme können beide Typen parallel nutzen. DNS kann je nach Netzwerkunterstützung A- oder AAAA-Records zurückliefern."
  },
  {
    "id": "kc_text_016",
    "type": "text",
    "prompt": "Erkläre den Unterschied zwischen TCP und UDP.",
    "rubric": [
      ["tcp"],
      ["udp"],
      ["zuverlaessig", "zuverlässig"],
      ["verbindung"],
      ["pakete"]
    ],
    "pass_ratio": 0.7,
    "min_words": 30,
    "example": "TCP ist ein verbindungsorientiertes und zuverlässiges Protokoll, das eine gesicherte Übertragung mit Reihenfolge- und Fehlerkontrolle bietet. UDP ist verbindungslos und verzichtet auf Bestätigungen oder Wiederholungen. Dadurch ist UDP schneller, aber weniger zuverlässig. TCP wird z.B. für HTTP oder SSH genutzt, UDP häufig für Streaming oder DNS. Die Wahl hängt von Zuverlässigkeit versus Geschwindigkeit ab."
  },
  {
    "id": "kc_text_017",
    "type": "text",
    "prompt": "Was bedeutet die Kombination aus IP-Adresse und Port?",
    "rubric": [
      ["ip"],
      ["port"],
      ["socket", "Kommunikationsendpunkt"],
      ["endpunkt"],
      ["verbindung"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Die Kombination aus IP-Adresse und Port bezeichnet einen eindeutigen Kommunikationsendpunkt (Socket). Die IP identifiziert den Host im Netzwerk, der Port den konkreten Dienst oder Prozess. Erst zusammen ist klar, wohin eine Verbindung gerichtet ist. Mehrere Dienste können auf derselben IP über unterschiedliche Ports erreichbar sein. Ohne Ports wäre keine saubere Trennung möglich."
  },
  {
    "id": "kc_text_018",
    "type": "text",
    "prompt": "Warum gelten zufällige IP-Adressen meist nicht als sinnvolle DNS-Server?",
    "rubric": [
      ["dns server"],
      ["rekursiv"],
      ["timeout"],
      ["refused"],
      ["nicht zuständig"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Eine zufällige IP-Adresse ist in der Regel kein DNS-Server oder erlaubt keine DNS-Abfragen. Solche Systeme antworten entweder gar nicht oder lehnen Anfragen ab. DNS-Server müssen speziell dafür konfiguriert sein und rekursive oder autoritative Anfragen erlauben. Öffentliche Resolver wie 8.8.8.8 sind explizit dafür vorgesehen. Zufällige Hosts erfüllen diese Rolle meist nicht."
  },
  {
    "id": "kc_text_019",
    "type": "text",
    "prompt": "Erkläre den Zweck von Port-Mapping bei Docker.",
    "rubric": [
      ["docker"],
      ["port mapping"],
      ["-p"],
      ["host"],
      ["container"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Port-Mapping bei Docker verbindet einen Port des Hosts mit einem Port im Container. Dadurch wird ein Dienst im Container vom Host oder extern erreichbar. Ohne Port-Mapping ist der Dienst nur innerhalb des Docker-Netzwerks sichtbar. Das Mapping wird beim Start mit -p hostPort:containerPort angegeben. Es ist eine bewusste Freigabe aus Sicherheitsgründen."
  },
  {
    "id": "kc_text_020",
    "type": "text",
    "prompt": "Warum ist CMD im Dockerfile keine Build-Anweisung, sondern eine Laufzeitdefinition?",
    "rubric": [
      ["cmd"],
      ["dockerfile"],
      ["container"],
      ["laufzeit"],
      ["start"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "CMD wird nicht beim Build ausgeführt, sondern erst beim Start eines Containers. Es legt fest, welcher Standardprozess im Container laufen soll. Das Image selbst bleibt unverändert, CMD wirkt nur zur Laufzeit. Zudem kann CMD beim docker run überschrieben werden. Deshalb ist CMD eine Laufzeitdefinition und keine Build-Anweisung."
  },
  {
    "id": "kc_text_021",
    "type": "text",
    "prompt": "Erkläre den Unterschied zwischen COPY und ADD im Dockerfile.",
    "rubric": [
      ["copy"],
      ["add"],
      ["dockerfile"],
      ["archive"],
      ["url"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "COPY kopiert Dateien oder Verzeichnisse direkt in das Image und ist einfach und vorhersehbar. ADD kann zusätzlich Archive automatisch entpacken und Inhalte von URLs laden. Aufgrund dieser Zusatzfunktionen ist ADD weniger transparent. Deshalb wird COPY in den meisten Fällen empfohlen. ADD sollte nur genutzt werden, wenn seine Sonderfunktionen bewusst benötigt werden."
  },
  {
    "id": "kc_text_022",
    "type": "text",
    "prompt": "Warum werden Docker-Container als isoliert bezeichnet?",
    "rubric": [
      ["docker"],
      ["isolation"],
      ["netzwerk"],
      ["prozess"],
      ["filesystem"]
    ],
    "pass_ratio": 0.7,
    "min_words": 25,
    "example": "Docker-Container sind isoliert, weil sie eigene Prozesse, eigene Netzwerkinterfaces und ein eigenes Dateisystem nutzen. Sie teilen nicht direkt den Zustand des Hosts oder anderer Container. Diese Isolation erhöht Sicherheit und Stabilität. Kommunikation erfolgt nur über explizite Mechanismen wie Netzwerke oder Port-Mapping. Dadurch lassen sich Anwendungen sauber voneinander trennen."
  }
]
